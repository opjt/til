import{_ as s,c as i,o as t,ag as e}from"./chunks/framework.B0zzL8Pn.js";const _=JSON.parse('{"title":"Linux Capability","description":"","frontmatter":{},"headers":[],"relativePath":"Tech/~/linux/linux-capability.md","filePath":"Tech/~/linux/linux-capability.md","lastUpdated":1765283984000}'),p={name:"Tech/~/linux/linux-capability.md"};function n(l,a,c,d,h,r){return t(),i("div",null,a[0]||(a[0]=[e(`<h1 id="linux-capability" tabindex="-1">Linux Capability <a class="header-anchor" href="#linux-capability" aria-label="Permalink to &quot;Linux Capability&quot;">​</a></h1><p>유닉스 시스템을 이어받은 리눅스에서는 ROOT 사용자가 프로세스를 실행할 때 아무런 제한이 없다.</p><p>리눅스는 모든 권한이 있거나, 아니거나 하는 이분법적 세계관을 지니고 있는데,<br> 커널 v2.2에 캐퍼빌리티 시스템 콜이 도입되면서 이런 세계관이 비틀어졌다.</p><h2 id="root-권한을-나눠줄게" tabindex="-1">root 권한을 나눠줄게 <a class="header-anchor" href="#root-권한을-나눠줄게" aria-label="Permalink to &quot;root 권한을 나눠줄게&quot;">​</a></h2><p>리눅스 <code>Capability</code>는 root 권한을 더 세밀하게 분할하여, 특정 권한만을 프로세스에게 부여할 수 있게 하는 기능이다.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pjt@lima-default:/Users/pjt$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> capsh</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --print</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Current:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Bounding</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read,cap_perfmon,cap_bpf,cap_checkpoint_restore</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Ambient</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Current</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> IAB:</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 생략</span></span></code></pre></div><p><code>capsh</code> 명령어로 현재 프로세스(쉘)의 캐퍼빌리티를 확인할 수 있다.</p><ul><li><code>Current</code>: 현재 프로세스가 실제로 활성화된 캐퍼빌리티</li><li><code>Bounding set</code></li></ul><h3 id="자주-사용하는-캐퍼빌리티" tabindex="-1">자주 사용하는 캐퍼빌리티 <a class="header-anchor" href="#자주-사용하는-캐퍼빌리티" aria-label="Permalink to &quot;자주 사용하는 캐퍼빌리티&quot;">​</a></h3><table tabindex="0"><thead><tr><th>캐퍼빌리티 이름</th><th>허용작업</th></tr></thead><tbody><tr><td>CAP_NET_BIND_SERVICE</td><td>1024번 미만의 특권 포트에 바인딩할 수 있도록 허용</td></tr><tr><td>CAP_CHOWN</td><td>파일의 소유자(UID/GID)를 임의로 변경할 수 있도록 허용</td></tr><tr><td>CAP_KILL</td><td>다른 사용자에게 속한 프로세스에 신호를 보낼 수 있게 함</td></tr><tr><td>CAP_SYS_CHROOT</td><td>chroot의 호출을 허용</td></tr><tr><td>CAP_SYS_ADMIN</td><td>파일시스템 마운트를 포함한 시스템 관리 작업을 허용</td></tr><tr><td>CAP_SETPCAP</td><td>실행 중인 프로세스의 캐퍼빌리티를 설정할 수 있도록 허용</td></tr></tbody></table><h3 id="사용-예" tabindex="-1">사용 예 <a class="header-anchor" href="#사용-예" aria-label="Permalink to &quot;사용 예&quot;">​</a></h3><p>만약 당신이 포트 80을 리스닝하는 웹서비스를 올린다고 했을 때 일반 사용자의 경우 <code>permission denied</code> 이 뜰것이다.<br> 리눅스에서는 1024번 미만의 포트(well-known ports)를 특권 포트(privileged ports)로 지정해놨기 때문입니다.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/sys/net/ipv4/ip_unprivileged_port_start</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1024</span></span></code></pre></div><ul><li>특권포트 확인.</li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stcap</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cap_net_bind_service=+ep</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./myserver</span></span></code></pre></div><p>로 권한을 주게 되면 정상적으로 실행할 수 있다.</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getcap</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ./myserver</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">./myserver</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cap_net_bind_service=ep</span></span></code></pre></div>`,17)]))}const k=s(p,[["render",n]]);export{_ as __pageData,k as default};
