import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.B0zzL8Pn.js";const d=JSON.parse('{"title":"도커의 컨테이너 구성 방법","description":"","frontmatter":{},"headers":[],"relativePath":"Tech/~/container/container-without-docker.md","filePath":"Tech/~/container/container-without-docker.md","lastUpdated":1764398733000}'),p={name:"Tech/~/container/container-without-docker.md"};function l(h,s,e,k,r,o){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="도커의-컨테이너-구성-방법" tabindex="-1">도커의 컨테이너 구성 방법 <a class="header-anchor" href="#도커의-컨테이너-구성-방법" aria-label="Permalink to &quot;도커의 컨테이너 구성 방법&quot;">​</a></h1><p>본 글은 <a href="https://www.youtube.com/watch?v=mSD88FuST80" target="_blank" rel="noreferrer">이게 돼요? 도커 없이 컨테이너 만들기 / if(kakao)2022</a> 영상을 보고 난 후 알게 된 점을 정리한 내용입니다.</p><h2 id="chroot" tabindex="-1">chroot <a class="header-anchor" href="#chroot" aria-label="Permalink to &quot;chroot&quot;">​</a></h2><p>아주 먼 옛날 최초의 격리 기술이라고 할 수 있는 chroot가 존재하였습니다 <strong>chroot</strong> 는 change root direcotry,말 그대로 루트 디렉토리를 변경하는 것이다</p><p>실제 도커 이미지를 통해 chroot 실습</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> export</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> $(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> tar</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -C</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx-root</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -xvf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chroot</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> nginx-root</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/bash</span></span></code></pre></div><p>하지만 현대 컨테이너 기술에서는 <strong>chroot</strong> 를 사용하지 않는다</p><ul><li>왜냐? &gt; chroot는 격리된 파일 시스템을 제공하긴 하지만, 가장 큰 문제로 탈옥이 가능하였음</li><li>그리고 다른 프로세스들이 보임.(파일적으로만 격리된 환경이기 때문)</li></ul><p>이러한 문제들을 리눅스의 네임스페이스 기능을 사용하여 해결해보자</p><h2 id="namespace" tabindex="-1">namespace <a class="header-anchor" href="#namespace" aria-label="Permalink to &quot;namespace&quot;">​</a></h2><blockquote><p>리눅스 커널에서 프로세스들을 서로 격리하기 위해 만든 기능. 각자의 그룹내에서 독립적인 환경을 구성하게 해준다</p></blockquote><p>docker를 사용할때 컨테이너 안에서 ps 를 하면 내 컨테이너의 안의 프로세스들만 보이는데 이러한 부분이 namespace 를 사용해서 격리된 컨테이너 환경을 만드는 것.</p><p>unshare 명령어를 통한 마운트 격리 실습</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unshare</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --mount</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bin/sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> new_root</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tmpfs</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> none</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> new_root</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> testdir</span></span></code></pre></div><p>이렇게 명령어를 입력하면 다른 쉘에서는 <code>testdir</code>이 보이지 않는 것을 확인 가능.</p><p>이렇게 되면 디렉토리가 격리는 되었지만 컨테이너에서 호스트의 루트 디렉토리에 접근할 수 있다</p><h3 id="pivot-root" tabindex="-1">pivot_root <a class="header-anchor" href="#pivot-root" aria-label="Permalink to &quot;pivot_root&quot;">​</a></h3><p>pivot_root는 루트 디렉토리를 바꾸는 역할이다. 어? 그러면chroot랑 똑같은 거 아닌가요?</p><ul><li>아님. <code>pivot_root</code>는 루트파일 시스템을 완전히 교체한다</li><li>이는 커널 system call로 <code>chroot</code>같은 눈속임 형태와 완전히 다름.</li></ul><p>pivot_root 실습</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unshare</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /bin/sh</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> tmpfs</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> none</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> new_root</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cp</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> myroot/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> new_root</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 리눅스 기본 명령어가 설치된 루트 디렉토리</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> new_root</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> old_root</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pivot_root</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> old_root</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # pivot_root {새로운 루트디렉토리} {기존 루트파일 시스템이 부착될 곳}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 격리된 공간과 호스트os에서 비교.</span></span></code></pre></div><p>이렇게 <code>pivot_root</code>를 통해 루트 디렉토리를 바꾸고 old_root를 삭제하게 되면 완전히 격리된 공간이 되는 것.</p><h2 id="overlay-file-system" tabindex="-1">Overlay File system <a class="header-anchor" href="#overlay-file-system" aria-label="Permalink to &quot;Overlay File system&quot;">​</a></h2><p>컨테이너 이미지들은 일반적으로 <strong>read-only</strong> 상태로 배포가 된다하지만 컨테이너를 실행하면, 그 이미지 위에 생성되는 변경사항은 유지가 되어야하는데</p><p>이때 사용하는 것이 오버레이 파일 시스템이다.</p><ul><li>오버레이 파일 시스템은 리눅스 커널에 내장된 <code>합성</code>파일 시스템이다</li><li>여러개의 디렉토리를 겹쳐서 하나의 디텍토리처럼 보여주고 싶을 때 사용함 (포토샵의 레이어 개념과 비슷)</li></ul><p>overlayFs 실습</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mkdir</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rootfs/{lower_base,lower,upper,merge,work}</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> base</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lower_base/base</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> test</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lower/file1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">mount</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -t</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> overlay</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> overlay</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -o</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lowerdir=lower_base/:lower/,upperdir=upper/,workdir=work/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> merge/</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ls</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rootfs/merge</span></span></code></pre></div><p>이 상태에서</p><ul><li>merge디렉토리에 있는 file1 을 지우게 되면 upper디렉토리에 노란색 글씨로 file1이 생기게 된다</li><li>이걸 <code>whute out</code>이라고 하는데 lower 디렉토리에 있는 원본 파일을 지우지 않고 삭제된 정보가 upper dir에 쓰여지게 되는 것.</li><li>이런식으로 원본 파일을 지우지 않고 보장할 수 있다.</li></ul><h2 id="cgroup-control-groups" tabindex="-1">Cgroup (Control groups) <a class="header-anchor" href="#cgroup-control-groups" aria-label="Permalink to &quot;Cgroup (Control groups)&quot;">​</a></h2><p>지금까지 격리된 공간을 구성하는데 집중하였지만 이제는 hostOS에서 컨테이너 자원을 어떻게 보장할 수 있을까? 에 대해 알아보자</p><p>우선 Cgroup에 대해 간단히 알아보면</p><ul><li>리눅스 커널 기능으로 프로세스들의 리소스 사용랴을 제한하는 기능</li><li>namespace만으로는 리소스를 통제할 수 없음.</li></ul><p>만약 특정 컨테이너가 자원을 무한정 끌어다 쓰게 되면 ? 나머지 컨테이너들은 자원을 못받으면서 시스템의 문제가 생김</p><p><code>mount | grep cgroup</code> 명령어를 통해 현재 어떤 버전의 cgroup을 사용하는지 알 수 있다.</p><p>Cgroup실습</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 실습에 필요한 패키지 설치</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -y</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cgroup-tools</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">apt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -y</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stress</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cgcreate</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> root</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cpu:mycgroup</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tree</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /sys/fs/cgroup/mycgroup/</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cgset</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -r</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cpu.max=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30000</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> mycgroup</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cgexec</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> cpu:mycgroup</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> stress</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -c</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 이후 다른 터미널에서</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">top</span></span></code></pre></div><ul><li><code>/sys/fs/cgroup/mycgroup</code> 경로에 들어가면 <code>cpu.max</code> 라는 파일에 <code>30000 100000</code> 라고 적혀져 있는 모습을 볼 수 있다</li><li>이는 100,000 마이크로초(0.1초) 중 30,000 마이크로초(0.03초) 동안만 CPU 사용을 허용한다는 뜻으로, 즉 약 30% CPU 사용 제한을 의미한다</li><li>이 설정 덕분에 해당 Cgroup에 속한 프로세스들은 cpu자원을 지정한 비율 이상 사용하지 못하게 되어 시스템 자원 과다 사용을 방지할 수 있음</li></ul>`,39)]))}const c=i(p,[["render",l]]);export{d as __pageData,c as default};
